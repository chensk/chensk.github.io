<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>go 读写锁原理解析 &mdash; 不加香菜</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/molokai.css"><link rel="canonical" href="https://chensk.github.io//2021/03/26/go-rwlock/"><link rel="alternate" type="application/atom+xml" title="不加香菜" href="https://chensk.github.io//feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/favicon.ico"><meta property="og:title" content="go 读写锁原理解析"><meta name="keywords" content="go, 并发, 读写锁, mutex"><meta name="og:keywords" content="go, 并发, 读写锁, mutex"><meta name="description" content="介绍go语言如何使用读写锁，重点分析了其实现原理，有助于理解高并发编程"><meta name="og:description" content="介绍go语言如何使用读写锁，重点分析了其实现原理，有助于理解高并发编程"><meta property="og:url" content="https://chensk.github.io//2021/03/26/go-rwlock/"><meta property="og:site_name" content="不加香菜"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-03-26"> <script src="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://chensk.github.io//" title="不加香菜"><span class="octicon octicon-mark-github"></span> 不加香菜</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://chensk.github.io//" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://chensk.github.io//categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://chensk.github.io//wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://chensk.github.io//about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="go 读写锁原理解析"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">go 读写锁原理解析</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/03/26 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://chensk.github.io//categories/#Go" title="Go">Go</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 5707 字，约 17 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><p>介绍go语言如何使用读写锁，重点分析了其实现原理，有助于理解高并发编程</p><h1 id="引言">引言</h1><p>锁是编程开发中用于并发控制的一种同步机制，提供多线程（或协程）之间并发读写一个共享数据的方法。在go语言中使用锁也很简单：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">loc</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
<span class="k">var</span> <span class="n">rwLoc</span> <span class="n">sync</span><span class="o">.</span><span class="n">RWMutex</span>
<span class="k">var</span> <span class="n">idx</span> <span class="kt">int</span>
<span class="k">var</span> <span class="n">writeRatio</span> <span class="o">=</span> <span class="m">3</span>

<span class="k">func</span> <span class="n">Inc</span><span class="p">(){</span>
   <span class="n">loc</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
   <span class="k">defer</span> <span class="n">loc</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
   <span class="n">timer</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">NewTimer</span><span class="p">(</span><span class="m">100</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
   <span class="k">select</span><span class="p">{</span>
   <span class="k">case</span> <span class="o">&lt;-</span> <span class="n">timer</span><span class="o">.</span><span class="n">C</span><span class="o">:</span>
      <span class="n">idx</span> <span class="o">++</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Dec</span><span class="p">(){</span>
   <span class="n">loc</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
   <span class="k">defer</span> <span class="n">loc</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
   <span class="n">timer</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">NewTimer</span><span class="p">(</span><span class="m">100</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
   <span class="k">select</span><span class="p">{</span>
   <span class="k">case</span> <span class="o">&lt;-</span> <span class="n">timer</span><span class="o">.</span><span class="n">C</span><span class="o">:</span>
      <span class="n">idx</span> <span class="o">--</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">(){</span>
   <span class="n">wg</span> <span class="o">:=</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">{}</span>
   <span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">6</span><span class="p">)</span>
   <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
         <span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
         <span class="n">Inc</span><span class="p">()</span>
      <span class="p">}()</span>
      <span class="k">go</span> <span class="k">func</span><span class="p">(){</span>
         <span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
         <span class="n">Dec</span><span class="p">()</span>
      <span class="p">}()</span>
   <span class="p">}</span>
   <span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
   <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"i: %vn"</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>使用标准包sync.Mutex即可标记一段<a href="https://baike.baidu.com/item/%E4%B8%B4%E7%95%8C%E5%8C%BA">临界区</a>，保证对数据的并发读写符合预期。 注意到每次读写变量<code class="language-plaintext highlighter-rouge">idx</code>的时候都需要加锁，也就是任一时候只有一个goroutine允许读写该变量，而事实上如果并发执行的goroutine都是读的操作，是没有必要加锁的（因为变量的内容并没有改变），加锁是为了处理写操作的goroutine能正确同步变量的值。那么有没有不负如来不负卿的双全法呢，既能正确同步写操作，又能避免读操作的无谓加锁？事实上这就是读写锁的目的。</p><h1 id="读写锁">读写锁</h1><p>简单地说，读写锁就是一种能保证：</p><ul><li>并发读操作之间不互斥；</li><li>并发写操作之间互斥；</li><li>并发读操作和写操作互斥；</li></ul><p>的锁。</p><p>go语言的sync包也包含了这一数据结构，即<code class="language-plaintext highlighter-rouge">RWMutex</code>，使用方法与普通的锁基本相同，唯一的区别在于读操作的加锁、释放锁用的是<code class="language-plaintext highlighter-rouge">RLock</code>方法和<code class="language-plaintext highlighter-rouge">RUnlock</code>方法：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">rwLoc</span> <span class="n">sync</span><span class="o">.</span><span class="n">RWMutex</span>
<span class="k">var</span> <span class="n">idx</span> <span class="kt">int</span>

<span class="k">func</span> <span class="n">ReadRW</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">rwLoc</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
   <span class="k">defer</span> <span class="n">rwLoc</span><span class="o">.</span><span class="n">RUnlock</span><span class="p">()</span>
   <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Fprint</span><span class="p">(</span><span class="n">ioutil</span><span class="o">.</span><span class="n">Discard</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">WriteRW</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">rwLoc</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
   <span class="k">defer</span> <span class="n">rwLoc</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
   <span class="n">idx</span> <span class="o">=</span> <span class="m">3</span>
<span class="p">}</span>
</code></pre></div></div><p>那么go是怎么实现读写锁的呢，让我们通过源码分析一下它的实现原理。</p><h1 id="源码分析">源码分析</h1><p>在看源码之前我们不妨先思考一下，如果自己实现，需要怎么设计这个数据结构来满足上面那三个要求，然后再参看源码会有更多理解。 首先，为了满足第二点和第三点要求，肯定需要一个互斥锁：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">RWMutex</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">w</span> <span class="n">Mutex</span> <span class="c">// held if there are pending writers</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div><p>这个互斥锁是在写操作时使用的：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">Lock</span><span class="p">(){</span>
    <span class="o">...</span>
    <span class="n">rw</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">Unlock</span><span class="p">(){</span>
    <span class="o">...</span>
    <span class="n">rw</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div><p>而读操作之间是不互斥的，因此读操作的RLock()过程并不获取这个互斥锁。但读写之间是互斥的，那么RLock()如果不获取互斥锁又怎么能阻塞住写操作呢？go语言的实现是这样的： 通过一个int32变量记录当前正在读的goroutine数：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">RWMutex</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">w</span>           <span class="n">Mutex</span> <span class="c">// held if there are pending writers</span>
    <span class="n">readerCount</span> <span class="kt">int32</span> <span class="c">// number of pending readers</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div><p>每次调用Rlock方法时将readerCount加1，对应地，每次调用RUnlock方法时将readerCount减1：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">RLock</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
        <span class="c">// 如果readerCount小于0则通过同步原语阻塞住，否则将readerCount加1后即返回</span>
        <span class="n">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerSem</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">RUnlock</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="o">-</span><span class="m">1</span><span class="p">);</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
    <span class="c">// 如果readerCount减1后小于0，则调用rUnlockSlow方法，将这个方法剥离出来是为了RUnlock可以内联，这样能进一步提升读操作时的取锁性能</span>
        <span class="n">rw</span><span class="o">.</span><span class="n">rUnlockSlow</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>既然每次RLock时都会将readerCount增加，那判断它是否小于0有什么意义呢？这就需要和写操作的取锁过程Lock()参看：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 总结一下Lock的流程：1. 阻塞新来的写操作；2. 阻塞新来的读操作；3. 等待之前的读操作完成；</span>
<span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">Lock</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 通过rw.w.Lock阻塞其它写操作</span>
    <span class="n">rw</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="c">// 将readerCount减去一个最大数（2的30次方，RWMutex能支持的最大同时读操作数），这样readerCount将变成一个小于0的很小的数，</span>
    <span class="c">// 后续再调RLock方法时将会因为readerCount&lt;0而阻塞住，这样也就阻塞住了新来的读请求</span>
    <span class="n">r</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="o">-</span><span class="n">rwmutexMaxReaders</span><span class="p">)</span> <span class="o">+</span> <span class="n">rwmutexMaxReaders</span>
    <span class="c">// 等待之前的读操作完成</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerWait</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
        <span class="n">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">writerSem</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>写操作获取锁时通过将readerCount改成一个很小的数保证新来的读操作会因为readerCount&lt;0而阻塞住；那之前未完成的读操作怎么处理呢？很简单，只要跟踪写操作Lock之前未完成的reader数就行了，这里通过一个int32变量readerWait来做这件事情：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">RWMutex</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">w</span>           <span class="n">Mutex</span> <span class="c">// held if there are pending writers</span>
    <span class="n">readerCount</span> <span class="kt">int32</span> <span class="c">// number of pending readers</span>
    <span class="n">readerWait</span>  <span class="kt">int32</span> <span class="c">// number of departing readers</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div><p>每次写操作Lock时会将当前readerCount数量记在readerWait里。 回想一下，当写操作Lock后readerCount会小于0，这时reader unlock时会执行rUnlockSlow方法，现在可以来看它的实现过程了：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">rUnlockSlow</span><span class="p">(</span><span class="n">r</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">r</span><span class="o">+</span><span class="m">1</span> <span class="o">==</span> <span class="m">0</span> <span class="o">||</span> <span class="n">r</span><span class="o">+</span><span class="m">1</span> <span class="o">==</span> <span class="o">-</span><span class="n">rwmutexMaxReaders</span> <span class="p">{</span>
        <span class="n">throw</span><span class="p">(</span><span class="s">"sync: RUnlock of unlocked RWMutex"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">// 每个reader完成读操作后将readerWait减小1</span>
    <span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerWait</span><span class="p">,</span> <span class="o">-</span><span class="m">1</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
        <span class="c">// 当readerWait为0时代表writer等待的所有reader都已经完成了，可以唤醒writer了</span>
        <span class="n">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">writerSem</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>最后再看写操作的释放锁过程：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">Unlock</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 将readerCount置回原来的值，这样reader又可以进入了</span>
    <span class="n">r</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="n">rwmutexMaxReaders</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">rwmutexMaxReaders</span> <span class="p">{</span>
        <span class="n">throw</span><span class="p">(</span><span class="s">"sync: Unlock of unlocked RWMutex"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">// 唤醒那些等待的reader</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="kt">int</span><span class="p">(</span><span class="n">r</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerSem</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">// 释放互斥锁，这样新的writer可以获得锁</span>
    <span class="n">rw</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div><p>将上面这些过程梳理一下：</p><ol><li>如果没有writer请求进来，则每个reader开始后只是将readerCount增1，完成后将readerCount减1，整个过程不阻塞，这样就做到“并发读操作之间不互斥”；</li><li>当有writer请求进来时首先通过互斥锁阻塞住新来的writer，做到“并发写操作之间互斥”；</li><li>然后将readerCount改成一个很小的值，从而阻塞住新来的reader；</li><li>记录writer进来之前未完成的reader数量，等待它们都完成后再唤醒writer；这样就做到了“并发读操作和写操作互斥”；</li><li>writer结束后将readerCount置回原来的值，保证新的reader不会被阻塞，然后唤醒之前等待的reader，再将互斥锁释放，使后续writer不会被阻塞。</li></ol><p>这就是go语言中读写锁的核心源码（简洁起见，这里将竞态部分的代码省略，TODO：竞态分析原理分析），相信看到这你已经对读写锁的实现原理了然于胸了，如果你感兴趣，不妨一起继续思考这几个问题。</p><h1 id="思考">思考</h1><h2 id="1-writer-lock时在判断是否有未完成的reader时为什么不使用r--0">1. writer lock时在判断是否有未完成的reader时为什么不使用<code class="language-plaintext highlighter-rouge">r != 0</code></h2><p>回想一下Lock方法：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">RWMutex</span><span class="p">)</span> <span class="n">Lock</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">rw</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="n">r</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerCount</span><span class="p">,</span> <span class="o">-</span><span class="n">rwmutexMaxReaders</span><span class="p">)</span> <span class="o">+</span> <span class="n">rwmutexMaxReaders</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">readerWait</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
        <span class="n">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">.</span><span class="n">writerSem</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>为了判断是否还有未完成的reader，直接判断 <code class="language-plaintext highlighter-rouge">r!= 0</code>不就行了吗，为什么还需要判断<code class="language-plaintext highlighter-rouge">atomic.AddInt32(&amp;rw.readerWait, r)!=0</code>？ 这是因为上面第三行和第四行的代码并不是原子的，这就意味着中间很有可能插进其它goroutine执行，假如某个时刻执行完第三行代码，r=1，也就是此时还有一个reader，但执行第四行之前先执行了该reader的goroutine，并且reader完成RUnlock操作，此时如果只判断<code class="language-plaintext highlighter-rouge">r!=0</code>就会错误地阻塞住，因为这时候已经没有未完成的reader了。而reader在执行RUnlock的时候会将readerWait减1，所以<code class="language-plaintext highlighter-rouge">readerWait+r</code>就代表未完成的reader数。 那么只判断<code class="language-plaintext highlighter-rouge">atomic.AddInt32(&amp;rw.readerWait, r)!=0</code>不就可以吗？理论上应该是可以的，先判断<code class="language-plaintext highlighter-rouge">r!=0</code>应该是一种短路操作：如果<code class="language-plaintext highlighter-rouge">r==0</code>那就不用执行<code class="language-plaintext highlighter-rouge">atomic.AddInt32</code>了（注意r==0时readerWait也等于0）。</p><h1 id="benchmark">Benchmark</h1><p>最后让我们通过Benchmark看看读写锁的性能提升有多少：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Read</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">loc</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
   <span class="k">defer</span> <span class="n">loc</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
   <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Fprint</span><span class="p">(</span><span class="n">ioutil</span><span class="o">.</span><span class="n">Discard</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
   <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Nanosecond</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">ReadRW</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">rwLoc</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
   <span class="k">defer</span> <span class="n">rwLoc</span><span class="o">.</span><span class="n">RUnlock</span><span class="p">()</span>
   <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Fprint</span><span class="p">(</span><span class="n">ioutil</span><span class="o">.</span><span class="n">Discard</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
   <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Nanosecond</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Write</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">loc</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
   <span class="k">defer</span> <span class="n">loc</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
   <span class="n">idx</span> <span class="o">=</span> <span class="m">3</span>
   <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Nanosecond</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">WriteRW</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">rwLoc</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
   <span class="k">defer</span> <span class="n">rwLoc</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
   <span class="n">idx</span> <span class="o">=</span> <span class="m">3</span>
   <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Nanosecond</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">BenchmarkLock</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">b</span><span class="o">.</span><span class="n">RunParallel</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">pb</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">PB</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">foo</span> <span class="o">:=</span> <span class="m">0</span>
      <span class="k">for</span> <span class="n">pb</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span> <span class="p">{</span>
         <span class="n">foo</span><span class="o">++</span>
         <span class="k">if</span> <span class="n">foo</span> <span class="o">%</span> <span class="n">writeRatio</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
            <span class="n">Write</span><span class="p">()</span>
         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">Read</span><span class="p">()</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">})</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">BenchmarkRWLock</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">b</span><span class="o">.</span><span class="n">RunParallel</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">pb</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">PB</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">foo</span> <span class="o">:=</span> <span class="m">0</span>
      <span class="k">for</span> <span class="n">pb</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span> <span class="p">{</span>
         <span class="n">foo</span><span class="o">++</span>
         <span class="k">if</span> <span class="n">foo</span> <span class="o">%</span> <span class="n">writeRatio</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
            <span class="n">WriteRW</span><span class="p">()</span>
         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">ReadRW</span><span class="p">()</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div><p>这里使用了go语言内置的Benchmark功能，执行<code class="language-plaintext highlighter-rouge">go test -bench='Benchmark.*Lock' -run=none mutex_test.go</code>即可触发benchmark运行，<code class="language-plaintext highlighter-rouge">-run=none</code>是为了跳过单测。 结果如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz
BenchmarkLock
BenchmarkLock-12      	  235062	      5025 ns/op
BenchmarkRWLock
BenchmarkRWLock-12    	  320209	      3834 ns/op
</code></pre></div></div><p>可以看出使用读写锁后耗时降低了24%左右。 上面writeRatio用于控制读、写的频率比例，即读:写=3，随着这个比例越高耗时降低的比例也越大，这里作个简单比较：</p><table><thead><tr><th>writeRatio</th><th>3</th><th>10</th><th>20</th><th>50</th><th>100</th><th>1000</th></tr></thead><tbody><tr><td>耗时降低</td><td>24%</td><td>71.3%</td><td>83.7%</td><td>90.9%</td><td>93.5%</td><td>95.7%</td></tr></tbody></table><p>可以看出当读的比例越高时，使用读写锁获得的性能提升比例越高。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://chensk.github.io/" target="_blank">不吃香菜的小鬼</a></li><li>本文链接：<a href="https://chensk.github.io//2021/03/26/go-rwlock/" target="_blank">https://chensk.github.io//2021/03/26/go-rwlock/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2021/03/26/go-rwlock/', clientID: '4a982617b73a3a872cd0', clientSecret: '365405956704f82b12afa0d1a692f489945f17ce', repo: 'chensk.github.io', owner: 'chensk', admin: ['chensk'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://chensk.github.io//assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="不吃香菜的小鬼">不吃香菜的小鬼</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/chensk/chensk.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://chensk.github.io//" title="首页" target="">首页</a></li><li> <a href="https://chensk.github.io//categories/" title="分类" target="">分类</a></li><li> <a href="https://chensk.github.io//wiki/" title="维基" target="">维基</a></li><li> <a href="https://chensk.github.io//about/" title="关于" target="">关于</a></li><li><a href="https://chensk.github.io//feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2021-03-25 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>

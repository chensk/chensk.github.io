<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>go语言happens-before原则及应用 &mdash; 不加香菜</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/molokai.css"><link rel="canonical" href="https://chensk.github.io//2021/03/28/go-happens-before/"><link rel="alternate" type="application/atom+xml" title="不加香菜" href="https://chensk.github.io//feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/favicon.ico"><meta property="og:title" content="go语言happens-before原则及应用"><meta name="keywords" content="go, happens-before, 并发, goroutine"><meta name="og:keywords" content="go, happens-before, 并发, goroutine"><meta name="description" content="了解go中happens-before规则，寻找并发程序不确定性中的确定性。"><meta name="og:description" content="了解go中happens-before规则，寻找并发程序不确定性中的确定性。"><meta property="og:url" content="https://chensk.github.io//2021/03/28/go-happens-before/"><meta property="og:site_name" content="不加香菜"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-03-28"> <script src="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://chensk.github.io//" title="不加香菜"><span class="octicon octicon-mark-github"></span> 不加香菜</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://chensk.github.io//" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://chensk.github.io//categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://chensk.github.io//wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://chensk.github.io//about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="go语言happens-bef"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">go语言happens-before原则及应用</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/03/28 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://chensk.github.io//categories/#Go" title="Go">Go</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 6524 字，约 19 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><p>了解go中<code class="language-plaintext highlighter-rouge">happens-before</code>规则，寻找并发程序不确定性中的确定性。</p><h1 id="引言">引言</h1><p>先抛开你所熟知的信号量、锁、同步原语等技术，思考这个问题：如何保证并发读写的准确性？一个没有任何并发编程经验的程序员可能会觉得很简单：这有什么问题呢，同时读写能有什么问题，最多就是读到过期的数据而已。一个理想的世界当然是这样，只可惜实际上的机器世界往往隐藏了很多不容易被察觉的事情。至少有两个行为会影响这个结论：</p><ul><li>编译器往往有指令重排序的优化；例如程序员看到的源代码是<code class="language-plaintext highlighter-rouge">a=3; b=4;</code>，而实际上执行的顺序可能是<code class="language-plaintext highlighter-rouge">b=4; a=3；</code>，这是因为编译器为了优化执行效率可能对指令进行重排序；</li><li>高级编程语言所支持的运算往往不是原子化的；例如<code class="language-plaintext highlighter-rouge">a += 3</code>实际上包含了读变量、加运算和写变量三次原子操作。既然整个过程并不是原子化的，就意味着随时有其它“入侵者”侵入修改数据。更为隐藏的例子：对于变量的读写甚至可能都不是原子化的。不同机器读写变量的过程可能是不同的，有些机器可能是64位数据一次性读写，而有些机器是32位数据一次读写。这就意味着一个64位的数据在后者的读写上实际上是分成两次完成的！试想，如果你试图读取一个64位数据的值，先读取了低32的数据，这时另一个线程切进来修改了整个数据的值，最后你再读取高32的值，将高32和低32的数据拼成完整的值，很明显会得到一个预期以外的数据。</li></ul><p>看起来，整个并发编程的世界里一切都是不确定的，我们不知道每次读取的变量到底是不是及时、准确的数据。幸运的是，很多语言都有一个<strong><code class="language-plaintext highlighter-rouge">happens-before</code></strong>的规则，能帮助我们在不确定的并发世界里寻找一丝确定性。</p><h1 id="happens-before">happens-before</h1><p>你可以把<code class="language-plaintext highlighter-rouge">happens-before</code>看作一种特殊的比较运算，就好像<code class="language-plaintext highlighter-rouge">&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;</code>一样。对应的，还有<code class="language-plaintext highlighter-rouge">happens-after</code>，它们之间的关系也好像<code class="language-plaintext highlighter-rouge">&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;</code>一样：</p><blockquote><p>如果a happens-before b，那么b happens-after a</p></blockquote><p>那是否存在既不满足<code class="language-plaintext highlighter-rouge">a happens-before b</code>，也不满足<code class="language-plaintext highlighter-rouge">b happens-before a</code>的情况呢，就好像既不满足<code class="language-plaintext highlighter-rouge">a&gt;b</code>，也不满足<code class="language-plaintext highlighter-rouge">b&gt;a</code>（意味着<code class="language-plaintext highlighter-rouge">b==a</code>)？当然是肯定的，这种情况称为：a和b <code class="language-plaintext highlighter-rouge">happen concurrently</code>，也就是同时发生，这就回到我们之前所熟知的世界里了。</p><p><code class="language-plaintext highlighter-rouge">happens-before</code>有什么用呢？它可以用来帮助我们厘清两个并发读写之间的关系。对于并发读写问题，我们最关心的经常是reader是否能准确观察到writer写入的值。<code class="language-plaintext highlighter-rouge">happens-before</code>正是为这个问题设计的，具体来说，要想让某次读取r准确观察到某次写入w，只需满足：</p><ol><li>w <code class="language-plaintext highlighter-rouge">happens-before</code> r；</li><li>对变量的其它写入w1，要么w1 <code class="language-plaintext highlighter-rouge">happens-before</code> w，要么r <code class="language-plaintext highlighter-rouge">happens-before</code> w1；简单理解就是没有其它写入覆盖这次写入；</li></ol><p>只要满足这两个条件，那我们就可以自信地肯定我们一定能读取到正确的值。</p><p>一个新的问题随之诞生：那如何判断<code class="language-plaintext highlighter-rouge">a happens-before b</code>是否成立呢？你可以类比思考数学里如何判断<code class="language-plaintext highlighter-rouge">a &gt; b</code>是否成立的过程，我们的做法很简单：</p><ol><li>基于一些简单的公理；例如自然数的自然大小：<code class="language-plaintext highlighter-rouge">3&gt;2&gt;1</code></li><li>基于比较运算符的传递性，也就是如果<code class="language-plaintext highlighter-rouge">a&gt;b且b&gt;c</code>，则<code class="language-plaintext highlighter-rouge">a&gt;c</code></li></ol><p>判断<code class="language-plaintext highlighter-rouge">a happens-before b</code>的过程也是类似的：根据一些简单的明确的<code class="language-plaintext highlighter-rouge">happens-before</code>关系，再结合<code class="language-plaintext highlighter-rouge">happens-before</code>的传递性，推导出我们所关心的w和r之间的<code class="language-plaintext highlighter-rouge">happens-before</code>关系。</p><blockquote><p><code class="language-plaintext highlighter-rouge">happens-before</code>传递性：如果a <code class="language-plaintext highlighter-rouge">happens-before</code> b，且b <code class="language-plaintext highlighter-rouge">happens-before</code> c，则a <code class="language-plaintext highlighter-rouge">happens-before</code> c</p></blockquote><p>因此我们只需要了解这些明确的<code class="language-plaintext highlighter-rouge">happens-before</code>关系，就能在并发世界里寻找到宝贵的确定性了。</p><h1 id="go语言中的happens-before关系">go语言中的happens-before关系</h1><p>具体的happens-before关系是因语言而异的，这里只介绍go语言相关的规则，感兴趣可以直接阅读<a href="https://golang.org/ref/mem">官方文档</a>，有更完整、准确的说明。</p><h2 id="自然执行">自然执行</h2><p>首先，最简单也是最直观的<code class="language-plaintext highlighter-rouge">happens-before</code>规则：</p><blockquote><p>在<strong>同一个goroutine里</strong>，书写在前的代码<code class="language-plaintext highlighter-rouge">happens-before</code>书写在后的代码。</p></blockquote><p>例如：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = 3; // (1)
b = 4; // (2)
</code></pre></div></div><p>则(1) <code class="language-plaintext highlighter-rouge">happens-before</code> (2)。我们上面提到指令重排序，也就是实际执行的顺序与书写的顺序可能不一致，但happens-before与指令重排序并不矛盾，即使可能发生指令重排序，我们依然可以说（1) <code class="language-plaintext highlighter-rouge">happens-before</code> (2)。</p><h2 id="初始化">初始化</h2><p>每个go文件都可以有一个<code class="language-plaintext highlighter-rouge">init</code>方法，用于执行某些初始化逻辑。当我们开始执行某个<code class="language-plaintext highlighter-rouge">main</code>方法时，go会先在一个goroutine里做初始化工作，也就是执行所有go文件的<code class="language-plaintext highlighter-rouge">init</code>方法，这个过程中go可能创建多个goroutine并发地执行，因此通常情况下各个<code class="language-plaintext highlighter-rouge">init</code>方法是没有<code class="language-plaintext highlighter-rouge">happens-before</code>关系的。关于<code class="language-plaintext highlighter-rouge">init</code>方法有两条<code class="language-plaintext highlighter-rouge">happens-before</code>规则：</p><blockquote><p>1.a 包导入了 b包，此时b包的<code class="language-plaintext highlighter-rouge">init</code>方法<code class="language-plaintext highlighter-rouge">happens-before</code> a包的所有代码；</p><p>2.所有<code class="language-plaintext highlighter-rouge">init</code>方法<code class="language-plaintext highlighter-rouge">happens-before</code> <code class="language-plaintext highlighter-rouge">main</code>方法；</p></blockquote><h2 id="goroutine">goroutine</h2><p>goroutine相关的规则主要是其创建和销毁的：</p><blockquote><p>1.goroutine的创建 <code class="language-plaintext highlighter-rouge">happens-before</code> 其执行；</p><p>2.goroutine的完成<strong>不保证</strong><code class="language-plaintext highlighter-rouge">happens-before</code>任何代码；</p></blockquote><p>第一条规则举个简单的例子即可：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">a</span> <span class="kt">string</span>

<span class="k">func</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c">// (1)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">hello</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">a</span> <span class="o">=</span> <span class="s">"hello, world"</span> <span class="c">// (2)</span>
	<span class="k">go</span> <span class="n">f</span><span class="p">()</span> <span class="c">// (3)</span>
<span class="p">}</span>
</code></pre></div></div><p>因为goroutine的创建 <code class="language-plaintext highlighter-rouge">happens-before</code> 其执行，所以(3) <code class="language-plaintext highlighter-rouge">happens-before</code> (1)，又因为自然执行的规则(2) <code class="language-plaintext highlighter-rouge">happens-before</code> (3)，根据传递性，所以(2) <code class="language-plaintext highlighter-rouge">happens-before</code> (1)，这样保证了我们每次打印出来的都是”hello world”而不是空字符串。</p><p>第二条规则是少见的否定句式，同样举个简单的例子：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">a</span> <span class="kt">string</span>

<span class="k">func</span> <span class="n">hello</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"hello"</span> <span class="p">}()</span> <span class="c">// (1)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c">// (2)</span>
<span class="p">}</span>
</code></pre></div></div><p>由于goroutine的完成<strong>不保证</strong><code class="language-plaintext highlighter-rouge">happens-before</code>任何代码，因此(1) happens-before (2)不成立，这样我们就不能保证每次打印的结果都是”hello”。</p><h2 id="通道">通道</h2><p>通道channel是go语言中用于goroutine之间通信的主要渠道，因此理解通道之间的happens-before规则也至关重要。</p><blockquote><p>1.对于缓冲通道，向通道发送数据<code class="language-plaintext highlighter-rouge">happens-before</code>从通道接收到数据</p></blockquote><p>结合一个例子：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">c</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>
<span class="k">var</span> <span class="n">a</span> <span class="kt">string</span>

<span class="k">func</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">a</span> <span class="o">=</span> <span class="s">"hello, world"</span> <span class="c">// (1)</span>
	<span class="n">c</span> <span class="o">&lt;-</span> <span class="m">0</span> <span class="c">// (2)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="n">f</span><span class="p">()</span> <span class="c">// (3)</span>
	<span class="o">&lt;-</span><span class="n">c</span> <span class="c">// (4)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c">// (5)</span>
<span class="p">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">c</code>是一个缓冲通道，因此向通道发送数据<code class="language-plaintext highlighter-rouge">happens-before</code>从通道接收到数据，也就是(2) <code class="language-plaintext highlighter-rouge">happens-before</code> (4)，再结合自然执行规则以及传递性不难推导出(1) happens-before (5)，也就是打印的结果保证是”hello world”。 有趣的是，如果我们把c的定义改为<code class="language-plaintext highlighter-rouge">var c = make(chan int)</code>也就是无缓冲通道，上面的结论就不存在了<strong><em>（注1）</em></strong>，打印的结果不一定为”hello world”，这是因为：</p><blockquote><p>2.对于无缓冲通道，从通道接收数据<code class="language-plaintext highlighter-rouge">happens-before</code>向通道发送数据</p></blockquote><p>我们可以将上述例子稍微调整下：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">c</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="k">var</span> <span class="n">a</span> <span class="kt">string</span>

<span class="k">func</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">a</span> <span class="o">=</span> <span class="s">"hello, world"</span> <span class="c">// (1)</span>
    <span class="o">&lt;-</span> <span class="n">c</span> <span class="c">// (2)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="n">f</span><span class="p">()</span> <span class="c">// (3)</span>
	<span class="n">c</span> <span class="o">&lt;-</span> <span class="m">10</span> <span class="c">// (4)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c">// (5)</span>
<span class="p">}</span>
</code></pre></div></div><p>对于无缓冲通道，(2) <code class="language-plaintext highlighter-rouge">happens-before</code> (4)，再根据传递性，(1) <code class="language-plaintext highlighter-rouge">happens-before</code> (5)，因此依然可以保证打印的结果是”hello world”。</p><p>可以这么理解这两者的差异，缓冲通道的目的是缓冲发送方发送的数据，这就意味着发送方很可能先发送数据，过一段时间后接收方才接收，或者发送方发送的速度超过接收方接收的速度，因此缓冲通道的发送<code class="language-plaintext highlighter-rouge">happens-before</code>接收就自然而然了；相反，非缓冲通道是没有缓冲区的，先发起的发送方和接收方都会阻塞至另一方准备好，如果我们使用了非缓冲通道，则意味着我们认为我们的场景下接收发生在发送之前，否则我们就会使用缓冲通道了，因此非缓冲通道的接收<code class="language-plaintext highlighter-rouge">happens-before</code>发送。</p><blockquote><p>3.对于缓冲通道，第k次接收<code class="language-plaintext highlighter-rouge">happens-before</code>第<code class="language-plaintext highlighter-rouge">k+C</code>次发送，<code class="language-plaintext highlighter-rouge">C</code>是缓冲通道的容量</p></blockquote><p>这条规则是缓冲通道的通用规则（有趣的是，上面针对非缓冲通道的第2条规则也可以看成这个规则的特例：<code class="language-plaintext highlighter-rouge">C</code>取0）。这个规则看起来复杂，我们看个例子就清晰了：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">limit</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// work是一个worker列表，其中的元素w都是可执行函数</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">w</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">work</span> <span class="p">{</span>
		<span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">w</span> <span class="k">func</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">limit</span> <span class="o">&lt;-</span> <span class="m">1</span> <span class="c">// (1)</span>
			<span class="n">w</span><span class="p">()</span> <span class="c">// (2)</span>
			<span class="o">&lt;-</span><span class="n">limit</span> <span class="c">// (3)</span>
		<span class="p">}(</span><span class="n">w</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">select</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div><p>我们先套用一下上面的规则，则：“第1次(3)<code class="language-plaintext highlighter-rouge">happens-before</code>第4次(1)”、“第2次(3)<code class="language-plaintext highlighter-rouge">happens-before</code>第5次(1)”、“第3次(3)<code class="language-plaintext highlighter-rouge">happens-before</code>第6次(1)”……，再结合传递性：“第1次(2)<code class="language-plaintext highlighter-rouge">happens-before</code>第1次(3)<code class="language-plaintext highlighter-rouge">happens-before</code>第4次(1)<code class="language-plaintext highlighter-rouge">happens-before</code>第4次(2)”、“第2次(2)<code class="language-plaintext highlighter-rouge">happens-before</code>第2次(3)<code class="language-plaintext highlighter-rouge">happens-before</code>第5次(1)<code class="language-plaintext highlighter-rouge">happens-before</code>第5次(2)”……，简单地说：“第1次(2)<code class="language-plaintext highlighter-rouge">happens-before</code>第4次(2)”、“第2次(2)<code class="language-plaintext highlighter-rouge">happens-before</code>第5次(2)”、“第3次(2)<code class="language-plaintext highlighter-rouge">happens-before</code>第6次(2)”……这样我们虽然没有做任何分批，却事实上将workers分成三个一批、每批并发地执行。这就是通过这条happens-before规则保证的。</p><p>这个规则理解起来其实也很简单，<code class="language-plaintext highlighter-rouge">C</code>是通道的容量，如果无法保证第k次接收<code class="language-plaintext highlighter-rouge">happens-before</code>第<code class="language-plaintext highlighter-rouge">k+C</code>次发送，那通道的缓冲就不够用了。</p><blockquote><p>注1：以上是官方文档给的规则和例子，但是笔者在尝试将第一个例子的<code class="language-plaintext highlighter-rouge">c</code>改成无缓冲通道后发现每次打印的依然稳定是”hello world”，并没有出现预期的空字符串，也就是看起来<code class="language-plaintext highlighter-rouge">happens-before</code>规则依然成立。但既然官方文档说无法保证，那我们开发时还是按照<code class="language-plaintext highlighter-rouge">happens-before</code>不成立比较好。</p></blockquote><h2 id="锁">锁</h2><p>锁也是并发编程里非常常用的一个数据结构。go语言中支持的锁主要有两种：<code class="language-plaintext highlighter-rouge">sync.Mutex</code>和<code class="language-plaintext highlighter-rouge">sync.RWMutex</code>，即普通锁和读写锁（读写锁的原理可以参见另一篇<a href="https://chensk.github.io//2021/03/26/go-rwlock/">文章</a>）。普通锁的<code class="language-plaintext highlighter-rouge">happens-before</code>规则也很直观：</p><blockquote><p>1.对锁实例调用<code class="language-plaintext highlighter-rouge">n</code>次<code class="language-plaintext highlighter-rouge">Unlock</code> <code class="language-plaintext highlighter-rouge">happens-before</code> 调用<code class="language-plaintext highlighter-rouge">Lock</code> <code class="language-plaintext highlighter-rouge">m</code>次，只要<code class="language-plaintext highlighter-rouge">n &lt; m</code></p></blockquote><p>请看这个例子：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">l</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
<span class="k">var</span> <span class="n">a</span> <span class="kt">string</span>

<span class="k">func</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">a</span> <span class="o">=</span> <span class="s">"hello, world"</span> <span class="c">// (1)</span>
	<span class="n">l</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span> <span class="c">// (2)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">l</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span> <span class="c">// (3)</span>
	<span class="k">go</span> <span class="n">f</span><span class="p">()</span> <span class="c">// (4)</span>
	<span class="n">l</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span> <span class="c">// (5)</span>
	<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c">// (6)</span>
<span class="p">}</span>
</code></pre></div></div><p>上面调用了<code class="language-plaintext highlighter-rouge">Unlock</code>一次，<code class="language-plaintext highlighter-rouge">Lock</code>两次，因此(2) <code class="language-plaintext highlighter-rouge">happens-before</code> (5)，从而(1) <code class="language-plaintext highlighter-rouge">happens-before</code> (6)</p><p>而读写锁的规则为：</p><blockquote><p>2.对读写锁实例的某一次<code class="language-plaintext highlighter-rouge">Unlock</code>调用，<code class="language-plaintext highlighter-rouge">happens-after</code>的<code class="language-plaintext highlighter-rouge">RLock</code>调用对应的<code class="language-plaintext highlighter-rouge">RUnlock</code>调用<code class="language-plaintext highlighter-rouge">happens-before</code>下一次<code class="language-plaintext highlighter-rouge">Lock</code>调用。</p></blockquote><p>其实本质就是读写锁的原理：读写互斥，简单地理解就是写锁释放后先获取了读锁，则读锁的释放会<code class="language-plaintext highlighter-rouge">happens-before</code> 下一次写锁的获取。注意上面的规则是“存在”，而不是“任意”。</p><h2 id="once">Once</h2><p>sync中还提供了一个<code class="language-plaintext highlighter-rouge">Once</code>的数据结构，用于控制并发编程中只执行一次的逻辑，例如：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">a</span> <span class="kt">string</span>
<span class="k">var</span> <span class="n">once</span> <span class="n">sync</span><span class="o">.</span><span class="n">Once</span>

<span class="k">func</span> <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">a</span> <span class="o">=</span> <span class="s">"hello, world"</span>
   <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"set up"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">doprint</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">once</span><span class="o">.</span><span class="n">Do</span><span class="p">(</span><span class="n">setup</span><span class="p">)</span>
   <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">twoprint</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="n">doprint</span><span class="p">()</span>
	<span class="k">go</span> <span class="n">doprint</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div><p>会打印”hello, world”两次和”set up”一次。<code class="language-plaintext highlighter-rouge">Once</code>的<code class="language-plaintext highlighter-rouge">happens-before</code>规则也很直观：</p><blockquote><p>第一次执行<code class="language-plaintext highlighter-rouge">Once.Do</code> <code class="language-plaintext highlighter-rouge">happens-before</code>其余的<code class="language-plaintext highlighter-rouge">Once.Do</code></p></blockquote><h1 id="应用">应用</h1><p>掌握了上述的基本<code class="language-plaintext highlighter-rouge">happens-before</code>规则，可以结合起来分析更复杂的场景了，来看这个例子：</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span>

<span class="k">func</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">a</span> <span class="o">=</span> <span class="m">1</span> <span class="c">// (1)</span>
	<span class="n">b</span> <span class="o">=</span> <span class="m">2</span> <span class="c">// (2)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">g</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c">// (3)</span>
	<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c">// (4)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="n">f</span><span class="p">()</span>
	<span class="n">g</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div><p>这里(1) <code class="language-plaintext highlighter-rouge">happens-before</code> (2)，(3) <code class="language-plaintext highlighter-rouge">happens-before</code>(4)，但是(1)与(3)、(4)之间以及(2)与(3)、(4)之间并没有<code class="language-plaintext highlighter-rouge">happens-before</code>关系，这时候结果是不确定的，一种有趣的结果是2、0，也就是(1)、(2)之间发生了指令重排序。现在让我们修改一下上面的代码，让它按我们预期的逻辑运行：要么打印0、0，要么打印1、2。</p><h2 id="使用锁">使用锁</h2><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span>
<span class="k">var</span> <span class="n">lock</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>

<span class="k">func</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span> <span class="c">// (1)</span>
	<span class="n">a</span> <span class="o">=</span> <span class="m">1</span> <span class="c">// (2)</span>
	<span class="n">b</span> <span class="o">=</span> <span class="m">2</span> <span class="c">// (3)</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span> <span class="c">// (4)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">g</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span> <span class="c">// (5)</span>
	<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c">// (6)</span>
	<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c">// (7)</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span> <span class="c">// (8)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="n">f</span><span class="p">()</span>
	<span class="n">g</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div><p>回想下锁的规则：</p><blockquote><p>1.对锁实例调用<code class="language-plaintext highlighter-rouge">n</code>次<code class="language-plaintext highlighter-rouge">Unlock</code> <code class="language-plaintext highlighter-rouge">happens-before</code> 调用<code class="language-plaintext highlighter-rouge">Lock</code> <code class="language-plaintext highlighter-rouge">m</code>次，只要<code class="language-plaintext highlighter-rouge">n &lt; m</code></p></blockquote><p>这里存在两种可能：要么(4) <code class="language-plaintext highlighter-rouge">happens-before</code> (5)，要么(8) <code class="language-plaintext highlighter-rouge">happens-before</code> (1)，会分别推导出两种结果：(6) <code class="language-plaintext highlighter-rouge">happens-before</code> (7) <code class="language-plaintext highlighter-rouge">happens-before</code> (2) <code class="language-plaintext highlighter-rouge">happens-before</code> (3) ，以及(2) <code class="language-plaintext highlighter-rouge">happens-before</code> (3) <code class="language-plaintext highlighter-rouge">happens-before</code> (6) <code class="language-plaintext highlighter-rouge">happens-before</code> (7)，也就分别对应“0、0”和“1、2”两种结果。</p><h2 id="使用通道">使用通道</h2><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span>
<span class="k">var</span> <span class="n">c</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>

<span class="k">func</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
   <span class="o">&lt;-</span> <span class="n">c</span>
   <span class="n">a</span> <span class="o">=</span> <span class="m">1</span> <span class="c">// (2)</span>
   <span class="n">b</span> <span class="o">=</span> <span class="m">2</span> <span class="c">// (3)</span>
   <span class="n">c</span> <span class="o">&lt;-</span> <span class="m">1</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">g</span><span class="p">()</span> <span class="p">{</span>
   <span class="o">&lt;-</span> <span class="n">c</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c">// (6)</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c">// (7)</span>
   <span class="n">c</span> <span class="o">&lt;-</span> <span class="m">1</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">wg</span> <span class="o">:=</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">{}</span>
   <span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
   <span class="k">go</span> <span class="k">func</span><span class="p">(){</span>
      <span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
      <span class="n">f</span><span class="p">()</span>
   <span class="p">}()</span>
   <span class="k">go</span> <span class="k">func</span><span class="p">(){</span>
      <span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
      <span class="n">g</span><span class="p">()</span>
   <span class="p">}()</span>
   <span class="k">go</span> <span class="k">func</span><span class="p">(){</span>
      <span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
      <span class="n">c</span> <span class="o">&lt;-</span> <span class="m">1</span>
   <span class="p">}()</span>
   <span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
   <span class="nb">close</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>总之，如果无法确定并发读写之间的<code class="language-plaintext highlighter-rouge">happens-before</code>关系，那么最好使用同步工具明确它们之间的关系，例如锁或者通道。不要给程序留下不确定的可能，毕竟确定性就是编程的魅力！</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://chensk.github.io/" target="_blank">不吃香菜的小鬼</a></li><li>本文链接：<a href="https://chensk.github.io//2021/03/28/go-happens-before/" target="_blank">https://chensk.github.io//2021/03/28/go-happens-before/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2021/03/28/go-happens-before/', clientID: '4a982617b73a3a872cd0', clientSecret: '365405956704f82b12afa0d1a692f489945f17ce', repo: 'chensk.github.io', owner: 'chensk', admin: ['chensk'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://chensk.github.io//assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="不吃香菜的小鬼">不吃香菜的小鬼</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/chensk/chensk.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://chensk.github.io//" title="首页" target="">首页</a></li><li> <a href="https://chensk.github.io//categories/" title="分类" target="">分类</a></li><li> <a href="https://chensk.github.io//wiki/" title="维基" target="">维基</a></li><li> <a href="https://chensk.github.io//about/" title="关于" target="">关于</a></li><li><a href="https://chensk.github.io//feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2021-03-25 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/chensk/chensk.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
